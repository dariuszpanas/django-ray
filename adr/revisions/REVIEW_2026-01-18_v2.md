# Django-Ray Project Review v2

**Date:** January 18, 2026  
**Focus:** Dead Code Analysis, Mode Consistency, Test Project Architecture

---

## Executive Summary

This review identifies several architectural concerns that have emerged during development:

1. **RayWorkerLease model is completely unused** - exists only in migrations and admin
2. **Three different Ray execution paths** with code duplication
3. **Test project only demonstrates one mode** - doesn't show different Django app patterns
4. **Several modules are stubs or partially implemented**

---

## 1. Dead Code: RayWorkerLease Model

### Current State - FIXED ✅

The `RayWorkerLease` model is now **fully integrated** into the worker command:

- **Lease Creation**: On worker startup via `_create_lease()`
- **Heartbeat Updates**: Every heartbeat interval via `send_heartbeat()`  
- **Lease Deletion**: On graceful shutdown via `shutdown()`

```python
# Worker now creates lease on startup
def _create_lease(self, queue: str) -> None:
    self.lease = RayWorkerLease.objects.create(
        worker_id=self.worker_id,
        hostname=socket.gethostname(),
        pid=os.getpid(),
        queue_name=queue,
    )

# Heartbeat updates lease
def send_heartbeat(self) -> None:
    if self.lease is not None:
        self.lease.last_heartbeat_at = timezone.now()
        self.lease.save(update_fields=["last_heartbeat_at"])

# Shutdown cleans up lease
def shutdown(self) -> None:
    if self.lease is not None:
        self.lease.delete()
```

### Tests Added

14 new tests in `tests/unit/test_leasing.py`:
- Worker ID generation tests
- Lease duration configuration tests
- Lease expiration detection tests
- Lease lifecycle tests (create, update, delete)

### Original Issue (RESOLVED)

```python
# models.py - EXISTS
class RayWorkerLease(models.Model):
    worker_id = models.CharField(max_length=255, primary_key=True)
    hostname = models.CharField(max_length=255)
    pid = models.PositiveIntegerField()
    queue_name = models.CharField(max_length=100, default="default")
    started_at = models.DateTimeField(default=timezone.now)
    last_heartbeat_at = models.DateTimeField(default=timezone.now)
```

### Where It Should Be Used

| File | Function | Should Use Lease | Actually Uses |
|------|----------|------------------|---------------|
| `django_ray_worker.py` | Worker startup | Create lease | ❌ Nothing |
| `django_ray_worker.py` | `send_heartbeat()` | Update `last_heartbeat_at` | ❌ Just prints "." |
| `django_ray_worker.py` | `shutdown()` | Delete lease | ❌ Nothing |
| `runner/leasing.py` | `is_lease_expired()` | Query leases | ✅ Has function but never called |

### Supporting Code (Also Unused)

The `runner/leasing.py` module has:
- `generate_worker_id()` - ✅ **Used** (for `claimed_by_worker` field)
- `get_lease_duration()` - ❌ **Unused**
- `get_heartbeat_interval()` - ✅ **Used** (but not for lease updates)
- `is_lease_expired()` - ❌ **Unused**

### Recommendation

**Option A: Implement Worker Leasing**
- Create lease on worker startup
- Update lease in `send_heartbeat()`
- Delete lease on shutdown
- Use for distributed worker coordination

**Option B: Remove Dead Code**
- Remove `RayWorkerLease` model
- Remove `runner/leasing.py` (except `generate_worker_id`)
- Simplify codebase

---

## 2. Ray Execution Mode Inconsistency

### Three Different Execution Paths

The worker has **three completely different** code paths:

| Mode | Flag | Implementation | Uses Runner? |
|------|------|----------------|--------------|
| Sync | `--sync` | Direct function call | ❌ No |
| Local/Cluster | `--local` / `--cluster` | Inline `@ray.remote` | ❌ No |
| Ray Job | (default) | `RayJobRunner` | ✅ Yes |

### Problem: Inline ray.remote

The `--local` and `--cluster` modes define a `@ray.remote` function **inline every time**:

```python
def execute_task_local_ray(self, task: RayTaskExecution) -> None:
    @ray.remote(name=f"django_ray:{task_name}")  # Re-defined every call!
    def run_task(...):
        ...
    result_ref = run_task.remote(...)
```

But `RayCoreRunner` exists with proper implementation:
- Proper `poll_completed()` method
- Tracks pending tasks
- Reusable across calls

### Problem: RayCoreRunner Never Used

Despite being fully implemented, `RayCoreRunner` is never instantiated:

```python
# runner/ray_core.py - FULLY IMPLEMENTED but never imported
class RayCoreRunner(BaseRunner):
    def submit(self, task_execution, callable_path, args, kwargs):
        ...
    def poll_completed(self):
        ...
```

### Recommendation

Refactor worker to use `RayCoreRunner` for `--local` and `--cluster` modes:

```python
def __init__(self):
    # ...
    self.runner: BaseRunner | None = None

def _init_local_ray(self):
    # ...
    self.runner = RayCoreRunner()

def process_task(self, task):
    if self.execution_mode == "sync":
        self.execute_task_sync(task)
    else:
        self.runner.submit(task, task.callable_path, args, kwargs)
```

---

## 3. Test Project: Single Mode Only

### Current Problem

The test project (`testproject/`) demonstrates only **one way** to use django-ray:

1. One Django app with tasks
2. One settings configuration
3. Tasks all use the same pattern

But Ray can be used in many different modes:
- **Sync mode**: Local testing without Ray
- **Local Ray**: Single-machine development
- **Remote Cluster**: Production distributed execution
- **Ray Actors**: Long-running stateful workers
- **Ray Job API**: Isolated job submission

### Proposed: Multiple Example Apps

Create separate Django apps demonstrating different patterns:

```
testproject/
├── settings.py           # Common settings
├── apps/
│   ├── sync_tasks/       # App 1: Sync execution (no Ray)
│   │   ├── __init__.py
│   │   ├── tasks.py      # Uses @task with sync backend
│   │   └── tests.py
│   │
│   ├── local_ray/        # App 2: Local Ray development
│   │   ├── __init__.py
│   │   ├── tasks.py      # CPU-bound tasks
│   │   └── tests.py
│   │
│   ├── cluster_tasks/    # App 3: Cluster deployment
│   │   ├── __init__.py
│   │   ├── tasks.py      # Distributed tasks
│   │   ├── actors.py     # Ray actor patterns
│   │   └── tests.py
│   │
│   └── ml_pipeline/      # App 4: ML use case
│       ├── __init__.py
│       ├── tasks.py      # Training tasks
│       ├── models.py     # ML model artifacts
│       └── tests.py
```

### Benefits

1. **Clear documentation**: Each app is a self-contained example
2. **Separate tests**: Test each mode independently
3. **Real patterns**: Shows actual use cases (ML, data processing, etc.)
4. **Mode switching**: Demonstrate how to switch backends per-queue

---

## 4. Stub Module Inventory

### Modules That Are Placeholders

| Module | Status | Purpose | Action |
|--------|--------|---------|--------|
| `results/external.py` | ❌ Stub | S3/GCS storage | Implement or remove |
| `runtime/redaction.py` | ⚠️ Partial | Log redaction | Finish or document |
| `metrics/prometheus.py` | ⚠️ Partial | Metrics collector class exists but not used by worker | Wire up |

### Modules That Work But Aren't Wired

| Module | Status | Issue |
|--------|--------|-------|
| `runner/ray_core.py` | ✅ Implemented | Not used by worker |
| `results/db.py` | ✅ Implemented | Not used consistently |

---

## 5. Specific Recommendations

### 5.1 Immediate: Fix Worker Leasing

```python
# In django_ray_worker.py handle()
def handle(self, *args, **options):
    # ... existing setup ...
    
    # Create worker lease
    from django_ray.models import RayWorkerLease
    import socket
    import os
    
    self.lease = RayWorkerLease.objects.create(
        worker_id=self.worker_id,
        hostname=socket.gethostname(),
        pid=os.getpid(),
        queue_name=queue,
    )
    
    try:
        self.run_loop(...)
    finally:
        self.lease.delete()  # Clean up on shutdown

def send_heartbeat(self):
    from django.utils import timezone
    self.lease.last_heartbeat_at = timezone.now()
    self.lease.save(update_fields=['last_heartbeat_at'])
    self.stdout.write(".", ending="")
```

### 5.2 Medium-term: Use Runner Abstraction

Refactor worker to always use a runner:

```python
class Command(BaseCommand):
    def __init__(self):
        self.runner: BaseRunner | None = None
    
    def _init_runner(self):
        if self.sync_mode:
            self.runner = SyncRunner()  # New: direct execution
        elif self.local_mode or self.cluster_address:
            self.runner = RayCoreRunner()
        else:
            self.runner = RayJobRunner()
    
    def process_task(self, task):
        handle = self.runner.submit(task, ...)
        # Unified tracking
```

### 5.3 Long-term: Multi-App Test Project

Restructure `testproject/` to demonstrate patterns:

1. **Basic Tasks App** - Simple CPU-bound tasks
2. **IO Tasks App** - Database/network tasks with proper timeouts
3. **ML Tasks App** - Training/inference pattern with result storage
4. **Actor Tasks App** - Stateful worker pattern

---

## 6. Test Coverage Gaps

### What's Tested

| Feature | Unit Test | Integration Test |
|---------|-----------|------------------|
| Task serialization | ✅ | ✅ |
| Sync execution | ✅ | ✅ |
| Retry logic | ✅ | ✅ |
| Settings validation | ✅ | - |
| API endpoints | - | ✅ |
| Stuck detection | - | ✅ |

### What's NOT Tested

| Feature | Status | Risk |
|---------|--------|------|
| Worker lease lifecycle | ❌ Not tested | High - dead code |
| RayCoreRunner | ❌ Not tested | Medium - code exists |
| RayJobRunner in production | ❌ Not tested | High - default path |
| Cluster mode (`--cluster`) | ❌ Not tested | High - K8s deployments |
| External result store | ❌ Not tested | Low - stub |
| Prometheus collector class | ❌ Not tested | Medium - exists |

### Recommended Test Additions

```python
# tests/unit/test_leasing.py
class TestWorkerLeasing:
    def test_lease_creation(self): ...
    def test_heartbeat_updates_lease(self): ...
    def test_expired_lease_detection(self): ...
    def test_lease_cleanup_on_shutdown(self): ...

# tests/integration/test_ray_core_runner.py  
class TestRayCoreRunner:
    def test_submit_task(self): ...
    def test_poll_completed(self): ...
    def test_cancel_task(self): ...

# tests/integration/test_cluster_mode.py
class TestClusterMode:
    @pytest.mark.skipif(not RAY_CLUSTER_AVAILABLE)
    def test_remote_execution(self): ...
```

---

## 7. Summary of Issues

| Issue | Severity | Effort | Status |
|-------|----------|--------|--------|
| RayWorkerLease unused | Medium | Low | ✅ **FIXED** |
| Inline ray.remote | Medium | Medium | Pending |
| RayCoreRunner not wired | Medium | Low | Pending |
| Single test app pattern | Low | High | ✅ **DONE** - Created 4 example apps |
| External store stub | Low | Medium | Pending |
| Missing tests for modes | High | Medium | ⚠️ Partial - Added leasing tests |

---

## 8. Action Items

### Phase 1: Clean Up (1 week)

- [ ] Wire up `RayWorkerLease` in worker command
- [ ] Add tests for worker leasing
- [ ] Remove or implement `results/external.py`
- [ ] Finish `runtime/redaction.py` or document as optional

### Phase 2: Consolidate Runners (1 week)

- [ ] Create `SyncRunner` for `--sync` mode
- [ ] Wire `RayCoreRunner` for `--local` and `--cluster`
- [ ] Remove inline `@ray.remote` from worker
- [ ] Add integration tests for each runner

### Phase 3: Multi-App Test Project (2 weeks)

- [ ] Create `testproject/apps/` structure
- [ ] Basic tasks app with sync backend
- [ ] ML pipeline app demonstrating Ray data
- [ ] Actor pattern app
- [ ] Update README with examples

---

## Appendix: Code Grep Results

### RayWorkerLease References

```
grep -r "RayWorkerLease" --include="*.py"
models.py:160:        class RayWorkerLease
admin.py:92:          @admin.register(RayWorkerLease)  
migrations/0001_initial.py:14:  name="RayWorkerLease"
runner/leasing.py:12:     from django_ray.models import RayWorkerLease  # TYPE_CHECKING only!
```

**Note**: Only imported for type hints, never actually used at runtime.

### RayWorkerLease.objects

```
grep -r "RayWorkerLease.objects" --include="*.py"
(no results)
```

**Confirmed**: Model is never queried, created, or updated.

